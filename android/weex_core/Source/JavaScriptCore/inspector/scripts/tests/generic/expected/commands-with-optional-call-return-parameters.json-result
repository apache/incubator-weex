### Begin File: InspectorBackendCommands.js
/*
 * Copyright (C) 2013 Google Inc. All rights reserved.
 * Copyright (C) 2013-2016 Apple Inc. All rights reserved.
 * Copyright (C) 2014 University of Washington. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

// DO NOT EDIT THIS FILE. It is automatically generated from commands-with-optional-call-return-parameters.json
// by the script: Source/JavaScriptCore/inspector/scripts/generate-inspector-protocol-bindings.py

// Database.
InspectorBackend.registerEnum("Database.PrimaryColors", {Red: "red", Green: "green", Blue: "blue"});
InspectorBackend.registerCommand("Database.executeAllOptionalParameters", [{"name": "columnNames", "type": "object", "optional": true}, {"name": "notes", "type": "string", "optional": true}, {"name": "timestamp", "type": "number", "optional": true}, {"name": "values", "type": "object", "optional": true}, {"name": "payload", "type": "object", "optional": true}, {"name": "databaseId", "type": "number", "optional": true}, {"name": "sqlError", "type": "object", "optional": true}, {"name": "screenColor", "type": "string", "optional": true}, {"name": "alternateColors", "type": "object", "optional": true}, {"name": "printColor", "type": "string", "optional": true}], ["columnNames", "notes", "timestamp", "values", "payload", "databaseId", "sqlError", "screenColor", "alternateColors", "printColor"]);
InspectorBackend.registerCommand("Database.executeNoOptionalParameters", [{"name": "columnNames", "type": "object", "optional": false}, {"name": "notes", "type": "string", "optional": false}, {"name": "timestamp", "type": "number", "optional": false}, {"name": "values", "type": "object", "optional": false}, {"name": "payload", "type": "object", "optional": false}, {"name": "databaseId", "type": "number", "optional": false}, {"name": "sqlError", "type": "object", "optional": false}, {"name": "screenColor", "type": "string", "optional": false}, {"name": "alternateColors", "type": "object", "optional": false}, {"name": "printColor", "type": "string", "optional": false}], ["columnNames", "notes", "timestamp", "values", "payload", "databaseId", "sqlError", "screenColor", "alternateColors", "printColor"]);
InspectorBackend.activateDomain("Database");
### End File: InspectorBackendCommands.js

### Begin File: TestAlternateBackendDispatchers.h
/*
 * Copyright (C) 2013 Google Inc. All rights reserved.
 * Copyright (C) 2013-2016 Apple Inc. All rights reserved.
 * Copyright (C) 2014 University of Washington. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

// DO NOT EDIT THIS FILE. It is automatically generated from commands-with-optional-call-return-parameters.json
// by the script: Source/JavaScriptCore/inspector/scripts/generate-inspector-protocol-bindings.py

#pragma once

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)

#include "TestProtocolTypes.h"
#include <inspector/InspectorFrontendRouter.h>
#include <JavaScriptCore/InspectorBackendDispatcher.h>

namespace Inspector {

class AlternateBackendDispatcher {
public:
    void setBackendDispatcher(RefPtr<BackendDispatcher>&& dispatcher) { m_backendDispatcher = WTFMove(dispatcher); }
    BackendDispatcher* backendDispatcher() const { return m_backendDispatcher.get(); }
private:
    RefPtr<BackendDispatcher> m_backendDispatcher;
};


class AlternateDatabaseBackendDispatcher : public AlternateBackendDispatcher {
public:
    virtual ~AlternateDatabaseBackendDispatcher() { }
    virtual void executeAllOptionalParameters(long callId, const Inspector::InspectorArray* in_columnNames, const String* const in_notes, const double* const in_timestamp, const Inspector::InspectorObject* in_values, const Inspector::InspectorValue* const in_payload, const int* const in_databaseId, const Inspector::InspectorObject* in_sqlError, const String* const in_screenColor, const Inspector::InspectorArray* in_alternateColors, const String* const in_printColor) = 0;
    virtual void executeNoOptionalParameters(long callId, const Inspector::InspectorArray& in_columnNames, const String& in_notes, double in_timestamp, const Inspector::InspectorObject& in_values, Inspector::InspectorValue in_payload, int in_databaseId, const Inspector::InspectorObject& in_sqlError, const String& in_screenColor, const Inspector::InspectorArray& in_alternateColors, const String& in_printColor) = 0;
};

} // namespace Inspector

#endif // ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
### End File: TestAlternateBackendDispatchers.h

### Begin File: TestBackendDispatchers.h
/*
 * Copyright (C) 2013 Google Inc. All rights reserved.
 * Copyright (C) 2013-2016 Apple Inc. All rights reserved.
 * Copyright (C) 2014 University of Washington. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

// DO NOT EDIT THIS FILE. It is automatically generated from commands-with-optional-call-return-parameters.json
// by the script: Source/JavaScriptCore/inspector/scripts/generate-inspector-protocol-bindings.py

#pragma once

#include "TestProtocolObjects.h"
#include <inspector/InspectorBackendDispatcher.h>
#include <wtf/text/WTFString.h>

namespace Inspector {

typedef String ErrorString;

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
class AlternateDatabaseBackendDispatcher;
#endif // ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)

class DatabaseBackendDispatcherHandler {
public:
    // Named after parameter 'printColor' while generating command/event executeAllOptionalParameters.
    enum class PrintColor {
        Cyan = 3,
        Magenta = 4,
        Yellow = 5,
        Black = 6,
    }; // enum class PrintColor
    virtual void executeAllOptionalParameters(ErrorString&, const Inspector::InspectorArray* opt_in_columnNames, const String* const opt_in_notes, const double* const opt_in_timestamp, const Inspector::InspectorObject* opt_in_values, const Inspector::InspectorValue* const opt_in_payload, const int* const opt_in_databaseId, const Inspector::InspectorObject* opt_in_sqlError, const String* const opt_in_screenColor, const Inspector::InspectorArray* opt_in_alternateColors, const String* const opt_in_printColor, RefPtr<Inspector::Protocol::Array<String>>& opt_out_columnNames, Inspector::Protocol::OptOutput<String>* opt_out_notes, Inspector::Protocol::OptOutput<double>* opt_out_timestamp, Inspector::Protocol::OptOutput<Inspector::InspectorObject>* opt_out_values, Inspector::Protocol::OptOutput<Inspector::InspectorValue>* opt_out_payload, Inspector::Protocol::OptOutput<int>* opt_out_databaseId, RefPtr<Inspector::Protocol::Database::Error>& opt_out_sqlError, Inspector::Protocol::Database::PrimaryColors* opt_out_screenColor, RefPtr<Inspector::Protocol::Database::ColorList>& opt_out_alternateColors, DatabaseBackendDispatcherHandler::PrintColor* opt_out_printColor) = 0;
    virtual void executeNoOptionalParameters(ErrorString&, const Inspector::InspectorArray& in_columnNames, const String& in_notes, double in_timestamp, const Inspector::InspectorObject& in_values, Inspector::InspectorValue in_payload, int in_databaseId, const Inspector::InspectorObject& in_sqlError, const String& in_screenColor, const Inspector::InspectorArray& in_alternateColors, const String& in_printColor, RefPtr<Inspector::Protocol::Array<String>>& out_columnNames, String* out_notes, double* out_timestamp, Inspector::InspectorObject* out_values, Inspector::InspectorValue* out_payload, int* out_databaseId, RefPtr<Inspector::Protocol::Database::Error>& out_sqlError, Inspector::Protocol::Database::PrimaryColors* out_screenColor, RefPtr<Inspector::Protocol::Database::ColorList>& out_alternateColors, DatabaseBackendDispatcherHandler::PrintColor* out_printColor) = 0;
protected:
    virtual ~DatabaseBackendDispatcherHandler();
};

class DatabaseBackendDispatcher final : public SupplementalBackendDispatcher {
public:
    static Ref<DatabaseBackendDispatcher> create(BackendDispatcher&, DatabaseBackendDispatcherHandler*);
    void dispatch(long requestId, const String& method, Ref<InspectorObject>&& message) override;
private:
    void executeAllOptionalParameters(long requestId, RefPtr<InspectorObject>&& parameters);
    void executeNoOptionalParameters(long requestId, RefPtr<InspectorObject>&& parameters);
#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
public:
    void setAlternateDispatcher(AlternateDatabaseBackendDispatcher* alternateDispatcher) { m_alternateDispatcher = alternateDispatcher; }
private:
    AlternateDatabaseBackendDispatcher* m_alternateDispatcher { nullptr };
#endif
private:
    DatabaseBackendDispatcher(BackendDispatcher&, DatabaseBackendDispatcherHandler*);
    DatabaseBackendDispatcherHandler* m_agent { nullptr };
};

} // namespace Inspector
### End File: TestBackendDispatchers.h

### Begin File: TestBackendDispatchers.cpp
/*
 * Copyright (C) 2013 Google Inc. All rights reserved.
 * Copyright (C) 2013-2016 Apple Inc. All rights reserved.
 * Copyright (C) 2014 University of Washington. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

// DO NOT EDIT THIS FILE. It is automatically generated from commands-with-optional-call-return-parameters.json
// by the script: Source/JavaScriptCore/inspector/scripts/generate-inspector-protocol-bindings.py

#include "config.h"
#include "TestBackendDispatchers.h"

#include <inspector/InspectorFrontendRouter.h>
#include <inspector/InspectorValues.h>
#include <wtf/NeverDestroyed.h>
#include <wtf/text/CString.h>

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
#include "TestAlternateBackendDispatchers.h"
#endif

namespace Inspector {

DatabaseBackendDispatcherHandler::~DatabaseBackendDispatcherHandler() { }

Ref<DatabaseBackendDispatcher> DatabaseBackendDispatcher::create(BackendDispatcher& backendDispatcher, DatabaseBackendDispatcherHandler* agent)
{
    return adoptRef(*new DatabaseBackendDispatcher(backendDispatcher, agent));
}

DatabaseBackendDispatcher::DatabaseBackendDispatcher(BackendDispatcher& backendDispatcher, DatabaseBackendDispatcherHandler* agent)
    : SupplementalBackendDispatcher(backendDispatcher)
    , m_agent(agent)
{
    m_backendDispatcher->registerDispatcherForDomain(ASCIILiteral("Database"), this);
}

void DatabaseBackendDispatcher::dispatch(long requestId, const String& method, Ref<InspectorObject>&& message)
{
    Ref<DatabaseBackendDispatcher> protect(*this);

    RefPtr<InspectorObject> parameters;
    message->getObject(ASCIILiteral("params"), parameters);

    if (method == "executeAllOptionalParameters")
        executeAllOptionalParameters(requestId, WTFMove(parameters));
    else if (method == "executeNoOptionalParameters")
        executeNoOptionalParameters(requestId, WTFMove(parameters));
    else
        m_backendDispatcher->reportProtocolError(BackendDispatcher::MethodNotFound, makeString('\'', "Database", '.', method, "' was not found"));
}

void DatabaseBackendDispatcher::executeAllOptionalParameters(long requestId, RefPtr<InspectorObject>&& parameters)
{
    bool opt_in_columnNames_valueFound = false;
    RefPtr<Inspector::InspectorArray> opt_in_columnNames = m_backendDispatcher->getArray(parameters.get(), ASCIILiteral("columnNames"), &opt_in_columnNames_valueFound);
    bool opt_in_notes_valueFound = false;
    String opt_in_notes = m_backendDispatcher->getString(parameters.get(), ASCIILiteral("notes"), &opt_in_notes_valueFound);
    bool opt_in_timestamp_valueFound = false;
    Inspector::Protocol::OptOutput<double> opt_in_timestamp = m_backendDispatcher->getDouble(parameters.get(), ASCIILiteral("timestamp"), &opt_in_timestamp_valueFound);
    bool opt_in_values_valueFound = false;
    RefPtr<Inspector::InspectorObject> opt_in_values = m_backendDispatcher->getObject(parameters.get(), ASCIILiteral("values"), &opt_in_values_valueFound);
    bool opt_in_payload_valueFound = false;
    RefPtr<Inspector::InspectorValue> opt_in_payload = m_backendDispatcher->getValue(parameters.get(), ASCIILiteral("payload"), &opt_in_payload_valueFound);
    bool opt_in_databaseId_valueFound = false;
    int opt_in_databaseId = m_backendDispatcher->getInteger(parameters.get(), ASCIILiteral("databaseId"), &opt_in_databaseId_valueFound);
    bool opt_in_sqlError_valueFound = false;
    RefPtr<Inspector::InspectorObject> opt_in_sqlError = m_backendDispatcher->getObject(parameters.get(), ASCIILiteral("sqlError"), &opt_in_sqlError_valueFound);
    bool opt_in_screenColor_valueFound = false;
    String opt_in_screenColor = m_backendDispatcher->getString(parameters.get(), ASCIILiteral("screenColor"), &opt_in_screenColor_valueFound);
    bool opt_in_alternateColors_valueFound = false;
    RefPtr<Inspector::InspectorArray> opt_in_alternateColors = m_backendDispatcher->getArray(parameters.get(), ASCIILiteral("alternateColors"), &opt_in_alternateColors_valueFound);
    bool opt_in_printColor_valueFound = false;
    String opt_in_printColor = m_backendDispatcher->getString(parameters.get(), ASCIILiteral("printColor"), &opt_in_printColor_valueFound);
    if (m_backendDispatcher->hasProtocolErrors()) {
        m_backendDispatcher->reportProtocolError(BackendDispatcher::InvalidParams, String::format("Some arguments of method '%s' can't be processed", "Database.executeAllOptionalParameters"));
        return;
    }

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->executeAllOptionalParameters(requestId, opt_in_columnNames_valueFound ? opt_in_columnNames.get() : nullptr, opt_in_notes_valueFound ? &opt_in_notes : nullptr, opt_in_timestamp_valueFound ? &opt_in_timestamp : nullptr, opt_in_values_valueFound ? opt_in_values.get() : nullptr, opt_in_payload_valueFound ? opt_in_payload.get() : nullptr, opt_in_databaseId_valueFound ? &opt_in_databaseId : nullptr, opt_in_sqlError_valueFound ? opt_in_sqlError.get() : nullptr, opt_in_screenColor_valueFound ? &opt_in_screenColor : nullptr, opt_in_alternateColors_valueFound ? opt_in_alternateColors.get() : nullptr, opt_in_printColor_valueFound ? &opt_in_printColor : nullptr);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    RefPtr<Inspector::Protocol::Array<String>> out_columnNames;
    Inspector::Protocol::OptOutput<String> out_notes;
    Inspector::Protocol::OptOutput<double> out_timestamp;
    Inspector::Protocol::OptOutput<Inspector::InspectorObject> out_values;
    Inspector::Protocol::OptOutput<Inspector::InspectorValue> out_payload;
    Inspector::Protocol::OptOutput<Inspector::Protocol::Database::DatabaseId> out_databaseId;
    RefPtr<Inspector::Protocol::Database::Error> out_sqlError;
    Inspector::Protocol::Database::PrimaryColors out_screenColor;
    RefPtr<Inspector::Protocol::Database::ColorList> out_alternateColors;
    DatabaseBackendDispatcherHandler::PrintColor out_printColor;
    m_agent->executeAllOptionalParameters(error, opt_in_columnNames_valueFound ? opt_in_columnNames.get() : nullptr, opt_in_notes_valueFound ? &opt_in_notes : nullptr, opt_in_timestamp_valueFound ? &opt_in_timestamp : nullptr, opt_in_values_valueFound ? opt_in_values.get() : nullptr, opt_in_payload_valueFound ? opt_in_payload.get() : nullptr, opt_in_databaseId_valueFound ? &opt_in_databaseId : nullptr, opt_in_sqlError_valueFound ? opt_in_sqlError.get() : nullptr, opt_in_screenColor_valueFound ? &opt_in_screenColor : nullptr, opt_in_alternateColors_valueFound ? opt_in_alternateColors.get() : nullptr, opt_in_printColor_valueFound ? &opt_in_printColor : nullptr, out_columnNames, &out_notes, &out_timestamp, out_values, &out_payload, &out_databaseId, out_sqlError, &out_screenColor, out_alternateColors, &out_printColor);

    if (!error.length()) {
        if (out_columnNames)
            result->setArray(ASCIILiteral("columnNames"), out_columnNames);
        if (out_notes.isAssigned())
            result->setString(ASCIILiteral("notes"), out_notes.getValue());
        if (out_timestamp.isAssigned())
            result->setDouble(ASCIILiteral("timestamp"), out_timestamp.getValue());
        if (out_values.isAssigned())
            result->setObject(ASCIILiteral("values"), out_values.getValue());
        if (out_payload.isAssigned())
            result->setValue(ASCIILiteral("payload"), out_payload.getValue());
        if (out_databaseId.isAssigned())
            result->setInteger(ASCIILiteral("databaseId"), out_databaseId.getValue());
        if (out_sqlError)
            result->setObject(ASCIILiteral("sqlError"), out_sqlError);
        if (out_screenColor.isAssigned())
            result->setString(ASCIILiteral("screenColor"), out_screenColor.getValue());
        if (out_alternateColors)
            result->setArray(ASCIILiteral("alternateColors"), out_alternateColors);
        if (out_printColor.isAssigned())
            result->setString(ASCIILiteral("printColor"), out_printColor.getValue());
    }
    if (!error.length())
        m_backendDispatcher->sendResponse(requestId, WTFMove(result));
    else
        m_backendDispatcher->reportProtocolError(BackendDispatcher::ServerError, WTFMove(error));
}

void DatabaseBackendDispatcher::executeNoOptionalParameters(long requestId, RefPtr<InspectorObject>&& parameters)
{
    RefPtr<Inspector::InspectorArray> in_columnNames = m_backendDispatcher->getArray(parameters.get(), ASCIILiteral("columnNames"), nullptr);
    String in_notes = m_backendDispatcher->getString(parameters.get(), ASCIILiteral("notes"), nullptr);
    double in_timestamp = m_backendDispatcher->getDouble(parameters.get(), ASCIILiteral("timestamp"), nullptr);
    RefPtr<Inspector::InspectorObject> in_values = m_backendDispatcher->getObject(parameters.get(), ASCIILiteral("values"), nullptr);
    RefPtr<Inspector::InspectorValue> in_payload = m_backendDispatcher->getValue(parameters.get(), ASCIILiteral("payload"), nullptr);
    int in_databaseId = m_backendDispatcher->getInteger(parameters.get(), ASCIILiteral("databaseId"), nullptr);
    RefPtr<Inspector::InspectorObject> in_sqlError = m_backendDispatcher->getObject(parameters.get(), ASCIILiteral("sqlError"), nullptr);
    String in_screenColor = m_backendDispatcher->getString(parameters.get(), ASCIILiteral("screenColor"), nullptr);
    RefPtr<Inspector::InspectorArray> in_alternateColors = m_backendDispatcher->getArray(parameters.get(), ASCIILiteral("alternateColors"), nullptr);
    String in_printColor = m_backendDispatcher->getString(parameters.get(), ASCIILiteral("printColor"), nullptr);
    if (m_backendDispatcher->hasProtocolErrors()) {
        m_backendDispatcher->reportProtocolError(BackendDispatcher::InvalidParams, String::format("Some arguments of method '%s' can't be processed", "Database.executeNoOptionalParameters"));
        return;
    }

#if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
    if (m_alternateDispatcher) {
        m_alternateDispatcher->executeNoOptionalParameters(requestId, *in_columnNames, in_notes, in_timestamp, *in_values, *in_payload, in_databaseId, *in_sqlError, in_screenColor, *in_alternateColors, in_printColor);
        return;
    }
#endif

    ErrorString error;
    Ref<InspectorObject> result = InspectorObject::create();
    RefPtr<Inspector::Protocol::Array<String>> out_columnNames;
    String out_notes;
    double out_timestamp;
    Inspector::InspectorObject out_values;
    Inspector::InspectorValue out_payload;
    Inspector::Protocol::Database::DatabaseId out_databaseId;
    RefPtr<Inspector::Protocol::Database::Error> out_sqlError;
    Inspector::Protocol::Database::PrimaryColors out_screenColor;
    RefPtr<Inspector::Protocol::Database::ColorList> out_alternateColors;
    DatabaseBackendDispatcherHandler::PrintColor out_printColor;
    m_agent->executeNoOptionalParameters(error, *in_columnNames, in_notes, in_timestamp, *in_values, *in_payload, in_databaseId, *in_sqlError, in_screenColor, *in_alternateColors, in_printColor, out_columnNames, &out_notes, &out_timestamp, out_values, &out_payload, &out_databaseId, out_sqlError, &out_screenColor, out_alternateColors, &out_printColor);

    if (!error.length()) {
        result->setArray(ASCIILiteral("columnNames"), out_columnNames);
        result->setString(ASCIILiteral("notes"), out_notes);
        result->setDouble(ASCIILiteral("timestamp"), out_timestamp);
        result->setObject(ASCIILiteral("values"), out_values);
        result->setValue(ASCIILiteral("payload"), out_payload);
        result->setInteger(ASCIILiteral("databaseId"), out_databaseId);
        result->setObject(ASCIILiteral("sqlError"), out_sqlError);
        result->setString(ASCIILiteral("screenColor"), Inspector::Protocol::TestHelpers::getEnumConstantValue(out_screenColor));
        result->setArray(ASCIILiteral("alternateColors"), out_alternateColors);
        result->setString(ASCIILiteral("printColor"), Inspector::Protocol::TestHelpers::getEnumConstantValue(out_printColor));
    }
    if (!error.length())
        m_backendDispatcher->sendResponse(requestId, WTFMove(result));
    else
        m_backendDispatcher->reportProtocolError(BackendDispatcher::ServerError, WTFMove(error));
}

} // namespace Inspector

### End File: TestBackendDispatchers.cpp

### Begin File: TestFrontendDispatchers.h
/*
 * Copyright (C) 2013 Google Inc. All rights reserved.
 * Copyright (C) 2013-2016 Apple Inc. All rights reserved.
 * Copyright (C) 2014 University of Washington. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

// DO NOT EDIT THIS FILE. It is automatically generated from commands-with-optional-call-return-parameters.json
// by the script: Source/JavaScriptCore/inspector/scripts/generate-inspector-protocol-bindings.py

#pragma once

#include "TestProtocolObjects.h"
#include <inspector/InspectorValues.h>
#include <wtf/text/WTFString.h>

namespace Inspector {

class FrontendRouter;

} // namespace Inspector
### End File: TestFrontendDispatchers.h

### Begin File: TestFrontendDispatchers.cpp
/*
 * Copyright (C) 2013 Google Inc. All rights reserved.
 * Copyright (C) 2013-2016 Apple Inc. All rights reserved.
 * Copyright (C) 2014 University of Washington. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

// DO NOT EDIT THIS FILE. It is automatically generated from commands-with-optional-call-return-parameters.json
// by the script: Source/JavaScriptCore/inspector/scripts/generate-inspector-protocol-bindings.py

#include "config.h"
#include "TestFrontendDispatchers.h"

#include "InspectorFrontendRouter.h"
#include <wtf/text/CString.h>

namespace Inspector {

} // namespace Inspector

### End File: TestFrontendDispatchers.cpp

### Begin File: TestProtocolObjects.h
/*
 * Copyright (C) 2013 Google Inc. All rights reserved.
 * Copyright (C) 2013-2016 Apple Inc. All rights reserved.
 * Copyright (C) 2014 University of Washington. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

// DO NOT EDIT THIS FILE. It is automatically generated from commands-with-optional-call-return-parameters.json
// by the script: Source/JavaScriptCore/inspector/scripts/generate-inspector-protocol-bindings.py

#pragma once

#include <inspector/InspectorProtocolTypes.h>
#include <wtf/Assertions.h>

namespace Inspector {



namespace Protocol {

// Forward declarations.
namespace Database {
class Error;
enum class PrimaryColors;
} // Database
// End of forward declarations.


// Typedefs.
namespace Database {
/* Unique identifier of Database object. */
typedef int DatabaseId;
typedef Inspector::Protocol::Array<Inspector::Protocol::Database::PrimaryColors> ColorList;
} // Database
// End of typedefs.

namespace TestHelpers {

String getEnumConstantValue(int code);

template<typename T> String getEnumConstantValue(T enumValue)
{
    return getEnumConstantValue(static_cast<int>(enumValue));
}

} // namespace TestHelpers

namespace Database {
/*  */
enum class PrimaryColors {
    Red = 0,
    Green = 1,
    Blue = 2,
}; // enum class PrimaryColors
/* Database error. */
class Error : public Inspector::InspectorObjectBase {
public:
    enum {
        NoFieldsSet = 0,
        MessageSet = 1 << 0,
        CodeSet = 1 << 1,
        AllFieldsSet = (MessageSet | CodeSet)
    };

    template<int STATE>
    class Builder {
    private:
        RefPtr<InspectorObject> m_result;

        template<int STEP> Builder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<Builder<STATE | STEP>*>(this);
        }

        Builder(Ref</*Error*/InspectorObject>&& object)
            : m_result(WTFMove(object))
        {
            COMPILE_ASSERT(STATE == NoFieldsSet, builder_created_in_non_init_state);
        }
        friend class Error;
    public:

        Builder<STATE | MessageSet>& setMessage(const String& value)
        {
            COMPILE_ASSERT(!(STATE & MessageSet), property_message_already_set);
            m_result->setString(ASCIILiteral("message"), value);
            return castState<MessageSet>();
        }

        Builder<STATE | CodeSet>& setCode(int value)
        {
            COMPILE_ASSERT(!(STATE & CodeSet), property_code_already_set);
            m_result->setInteger(ASCIILiteral("code"), value);
            return castState<CodeSet>();
        }

        Ref<Error> release()
        {
            COMPILE_ASSERT(STATE == AllFieldsSet, result_is_not_ready);
            COMPILE_ASSERT(sizeof(Error) == sizeof(InspectorObject), cannot_cast);

            Ref<InspectorObject> result = m_result.releaseNonNull();
            return WTFMove(*reinterpret_cast<Ref<Error>*>(&result));
        }
    };

    /*
     * Synthetic constructor:
     * Ref<Error> result = Error::create()
     *     .setMessage(...)
     *     .setCode(...)
     *     .release();
     */
    static Builder<NoFieldsSet> create()
    {
        return Builder<NoFieldsSet>(InspectorObject::create());
    }
};

} // Database



namespace TestHelpers {

template<typename ProtocolEnumType>
std::optional<ProtocolEnumType> parseEnumValueFromString(const String&);

// Enums in the 'Database' Domain
template<>
std::optional<Inspector::Protocol::Database::PrimaryColors> parseEnumValueFromString<Inspector::Protocol::Database::PrimaryColors>(const String&);

} // namespace TestHelpers

} // namespace Protocol

} // namespace Inspector
### End File: TestProtocolObjects.h

### Begin File: TestProtocolObjects.cpp
/*
 * Copyright (C) 2013 Google Inc. All rights reserved.
 * Copyright (C) 2013-2016 Apple Inc. All rights reserved.
 * Copyright (C) 2014 University of Washington. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

// DO NOT EDIT THIS FILE. It is automatically generated from commands-with-optional-call-return-parameters.json
// by the script: Source/JavaScriptCore/inspector/scripts/generate-inspector-protocol-bindings.py

#include "config.h"
#include "TestProtocolObjects.h"

#include <wtf/Optional.h>
#include <wtf/text/CString.h>

namespace Inspector {

namespace Protocol {

namespace TestHelpers {

static const char* const enum_constant_values[] = {
    "red",
    "green",
    "blue",
    "cyan",
    "magenta",
    "yellow",
    "black",
};

String getEnumConstantValue(int code) {
    return enum_constant_values[code];
}

// Enums in the 'Database' Domain
template<>
std::optional<Inspector::Protocol::Database::PrimaryColors> parseEnumValueFromString<Inspector::Protocol::Database::PrimaryColors>(const String& protocolString)
{
    static const size_t constantValues[] = {
        (size_t)Inspector::Protocol::Database::PrimaryColors::Red,
        (size_t)Inspector::Protocol::Database::PrimaryColors::Green,
        (size_t)Inspector::Protocol::Database::PrimaryColors::Blue,
    };
    for (size_t i = 0; i < 3; ++i)
        if (protocolString == enum_constant_values[constantValues[i]])
            return (Inspector::Protocol::Database::PrimaryColors)constantValues[i];

    return std::nullopt;
}


} // namespace TestHelpers



} // namespace Protocol

} // namespace Inspector

### End File: TestProtocolObjects.cpp

### Begin File: TestProtocolBackendDispatchers.h
/*
 * Copyright (C) 2013 Google Inc. All rights reserved.
 * Copyright (C) 2013-2016 Apple Inc. All rights reserved.
 * Copyright (C) 2014 University of Washington. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

// DO NOT EDIT THIS FILE. It is automatically generated from commands-with-optional-call-return-parameters.json
// by the script: Source/JavaScriptCore/inspector/scripts/generate-inspector-protocol-bindings.py

#include <JavaScriptCore/InspectorAlternateBackendDispatchers.h>
#include <wtf/RetainPtr.h>

@protocol TestProtocolDatabaseDomainHandler;

namespace Inspector {


class ObjCInspectorDatabaseBackendDispatcher final : public AlternateDatabaseBackendDispatcher {
public:
    ObjCInspectorDatabaseBackendDispatcher(id<TestProtocolDatabaseDomainHandler> handler) { m_delegate = handler; }
    virtual void executeAllOptionalParameters(long requestId, const Inspector::InspectorArray* in_columnNames, const String* const in_notes, const double* const in_timestamp, const Inspector::InspectorObject* in_values, const Inspector::InspectorValue* const in_payload, const int* const in_databaseId, const Inspector::InspectorObject* in_sqlError, const String* const in_screenColor, const Inspector::InspectorArray* in_alternateColors, const String* const in_printColor) override;
    virtual void executeNoOptionalParameters(long requestId, const Inspector::InspectorArray& in_columnNames, const String& in_notes, double in_timestamp, const Inspector::InspectorObject& in_values, Inspector::InspectorValue in_payload, int in_databaseId, const Inspector::InspectorObject& in_sqlError, const String& in_screenColor, const Inspector::InspectorArray& in_alternateColors, const String& in_printColor) override;
private:
    RetainPtr<id<TestProtocolDatabaseDomainHandler>> m_delegate;
};

} // namespace Inspector

### End File: TestProtocolBackendDispatchers.h

### Begin File: TestProtocolBackendDispatchers.mm
/*
 * Copyright (C) 2013 Google Inc. All rights reserved.
 * Copyright (C) 2013-2016 Apple Inc. All rights reserved.
 * Copyright (C) 2014 University of Washington. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

// DO NOT EDIT THIS FILE. It is automatically generated from commands-with-optional-call-return-parameters.json
// by the script: Source/JavaScriptCore/inspector/scripts/generate-inspector-protocol-bindings.py

#import "config.h"
#import "TestProtocolBackendDispatchers.h"

#include "TestProtocolInternal.h"
#include "TestProtocolTypeConversions.h"
#include <JavaScriptCore/InspectorValues.h>

namespace Inspector {

void ObjCInspectorDatabaseBackendDispatcher::executeAllOptionalParameters(long requestId, const Inspector::InspectorArray* in_columnNames, const String* const in_notes, const double* const in_timestamp, const Inspector::InspectorObject* in_values, const Inspector::InspectorValue* const in_payload, const int* const in_databaseId, const Inspector::InspectorObject* in_sqlError, const String* const in_screenColor, const Inspector::InspectorArray* in_alternateColors, const String* const in_printColor)
{
    id errorCallback = ^(NSString *error) {
        backendDispatcher()->reportProtocolError(requestId, BackendDispatcher::ServerError, error);
        backendDispatcher()->sendPendingErrors();
    };

    id successCallback = ^(NSArray/*<NSString>*/ **columnNames, NSString **notes, double *timestamp, RWIProtocolJSONObject **values, RWIProtocolJSONObject **payload, int *databaseId, TestProtocolDatabaseError **sqlError, TestProtocolDatabasePrimaryColors *screenColor, NSArray/*<NSString>*/ **alternateColors, TestProtocolDatabaseExecuteAllOptionalParametersPrintColor *printColor) {
        Ref<InspectorObject> resultObject = InspectorObject::create();
        THROW_EXCEPTION_FOR_BAD_OPTIONAL_PARAMETER(columnNames, @"columnNames");
        THROW_EXCEPTION_FOR_BAD_OPTIONAL_PARAMETER(notes, @"notes");
        THROW_EXCEPTION_FOR_BAD_OPTIONAL_PARAMETER(values, @"values");
        THROW_EXCEPTION_FOR_BAD_OPTIONAL_PARAMETER(payload, @"payload");
        THROW_EXCEPTION_FOR_BAD_OPTIONAL_PARAMETER(sqlError, @"sqlError");
        THROW_EXCEPTION_FOR_BAD_OPTIONAL_PARAMETER(alternateColors, @"alternateColors");
        if (columnNames)
            resultObject->setArray(ASCIILiteral("columnNames"), inspectorStringArray(*columnNames));
        if (notes)
            resultObject->setString(ASCIILiteral("notes"), *notes);
        if (timestamp)
            resultObject->setDouble(ASCIILiteral("timestamp"), *timestamp);
        if (values)
            resultObject->setObject(ASCIILiteral("values"), [*values toInspectorObject]);
        if (payload)
            resultObject->setValue(ASCIILiteral("payload"), [*payload toInspectorObject]);
        if (databaseId)
            resultObject->setInteger(ASCIILiteral("databaseId"), *databaseId);
        if (sqlError)
            resultObject->setObject(ASCIILiteral("sqlError"), [*sqlError toInspectorObject]);
        if (screenColor)
            resultObject->setString(ASCIILiteral("screenColor"), toProtocolString(*screenColor));
        if (alternateColors)
            resultObject->setArray(ASCIILiteral("alternateColors"), inspectorStringArray(*alternateColors));
        if (printColor)
            resultObject->setString(ASCIILiteral("printColor"), toProtocolString(*printColor));
        backendDispatcher()->sendResponse(requestId, WTFMove(resultObject));
    };

    NSArray/*<NSString>*/ *o_in_columnNames;
    if (in_columnNames)
        o_in_columnNames = objcStringArray(in_columnNames);
    NSString *o_in_notes;
    if (in_notes)
        o_in_notes = *in_notes;
    double o_in_timestamp;
    if (in_timestamp)
        o_in_timestamp = *in_timestamp;
    RWIProtocolJSONObject *o_in_values;
    if (in_values)
        o_in_values = [[[RWIProtocolJSONObject alloc] initWithInspectorObject:in_values] autorelease];
    RWIProtocolJSONObject *o_in_payload;
    if (in_payload)
        o_in_payload = [[[RWIProtocolJSONObject alloc] initWithInspectorObject:in_payload] autorelease];
    int o_in_databaseId;
    if (in_databaseId)
        o_in_databaseId = *in_databaseId;
    TestProtocolDatabaseError *o_in_sqlError;
    if (in_sqlError)
        o_in_sqlError = [[[TestProtocolDatabaseError alloc] initWithInspectorObject:in_sqlError] autorelease];
    std::optional<TestProtocolDatabasePrimaryColors> o_in_screenColor;
    if (in_screenColor)
        o_in_screenColor = fromProtocolString<TestProtocolDatabasePrimaryColors>(*in_screenColor);
    NSArray/*<NSString>*/ *o_in_alternateColors;
    if (in_alternateColors)
        o_in_alternateColors = objcStringArray(in_alternateColors);
    std::optional<TestProtocolDatabaseExecuteAllOptionalParametersPrintColor> o_in_printColor;
    if (in_printColor)
        o_in_printColor = fromProtocolString<TestProtocolDatabaseExecuteAllOptionalParametersPrintColor>(*in_printColor);

    [m_delegate executeAllOptionalParametersWithErrorCallback:errorCallback successCallback:successCallback columnNames:(in_columnNames ? &o_in_columnNames : nil) notes:(in_notes ? &o_in_notes : nil) timestamp:(in_timestamp ? &o_in_timestamp : nil) values:(in_values ? &o_in_values : nil) payload:(in_payload ? &o_in_payload : nil) databaseId:(in_databaseId ? &o_in_databaseId : nil) sqlError:(in_sqlError ? &o_in_sqlError : nil) screenColor:(in_screenColor ? &o_in_screenColor : nil) alternateColors:(in_alternateColors ? &o_in_alternateColors : nil) printColor:(in_printColor ? &o_in_printColor : nil)];
}

void ObjCInspectorDatabaseBackendDispatcher::executeNoOptionalParameters(long requestId, const Inspector::InspectorArray& in_columnNames, const String& in_notes, double in_timestamp, const Inspector::InspectorObject& in_values, Inspector::InspectorValue in_payload, int in_databaseId, const Inspector::InspectorObject& in_sqlError, const String& in_screenColor, const Inspector::InspectorArray& in_alternateColors, const String& in_printColor)
{
    id errorCallback = ^(NSString *error) {
        backendDispatcher()->reportProtocolError(requestId, BackendDispatcher::ServerError, error);
        backendDispatcher()->sendPendingErrors();
    };

    id successCallback = ^(NSArray/*<NSString>*/ *columnNames, NSString *notes, double timestamp, RWIProtocolJSONObject *values, RWIProtocolJSONObject *payload, int databaseId, TestProtocolDatabaseError *sqlError, TestProtocolDatabasePrimaryColors screenColor, NSArray/*<NSString>*/ *alternateColors, TestProtocolDatabaseExecuteNoOptionalParametersPrintColor printColor) {
        Ref<InspectorObject> resultObject = InspectorObject::create();
        THROW_EXCEPTION_FOR_REQUIRED_PARAMETER(columnNames, @"columnNames");
        THROW_EXCEPTION_FOR_REQUIRED_PARAMETER(notes, @"notes");
        THROW_EXCEPTION_FOR_REQUIRED_PARAMETER(values, @"values");
        THROW_EXCEPTION_FOR_REQUIRED_PARAMETER(payload, @"payload");
        THROW_EXCEPTION_FOR_REQUIRED_PARAMETER(sqlError, @"sqlError");
        THROW_EXCEPTION_FOR_REQUIRED_PARAMETER(alternateColors, @"alternateColors");
        resultObject->setArray(ASCIILiteral("columnNames"), inspectorStringArray(columnNames));
        resultObject->setString(ASCIILiteral("notes"), notes);
        resultObject->setDouble(ASCIILiteral("timestamp"), timestamp);
        resultObject->setObject(ASCIILiteral("values"), [values toInspectorObject]);
        resultObject->setValue(ASCIILiteral("payload"), [payload toInspectorObject]);
        resultObject->setInteger(ASCIILiteral("databaseId"), databaseId);
        resultObject->setObject(ASCIILiteral("sqlError"), [sqlError toInspectorObject]);
        resultObject->setString(ASCIILiteral("screenColor"), toProtocolString(screenColor));
        resultObject->setArray(ASCIILiteral("alternateColors"), inspectorStringArray(alternateColors));
        resultObject->setString(ASCIILiteral("printColor"), toProtocolString(printColor));
        backendDispatcher()->sendResponse(requestId, WTFMove(resultObject));
    };

    NSArray/*<NSString>*/ *o_in_columnNames = objcStringArray(&in_columnNames);
    NSString *o_in_notes = in_notes;
    double o_in_timestamp = in_timestamp;
    RWIProtocolJSONObject *o_in_values = [[[RWIProtocolJSONObject alloc] initWithInspectorObject:&in_values] autorelease];
    RWIProtocolJSONObject *o_in_payload = [[[RWIProtocolJSONObject alloc] initWithInspectorObject:&in_payload] autorelease];
    int o_in_databaseId = in_databaseId;
    TestProtocolDatabaseError *o_in_sqlError = [[[TestProtocolDatabaseError alloc] initWithInspectorObject:&in_sqlError] autorelease];
    std::optional<TestProtocolDatabasePrimaryColors> o_in_screenColor = fromProtocolString<TestProtocolDatabasePrimaryColors>(in_screenColor);
    if (!o_in_screenColor) {
        backendDispatcher()->reportProtocolError(BackendDispatcher::InvalidParams, String::format("Parameter '%s' of method '%s' cannot be processed", "screenColor", "Database.executeNoOptionalParameters"));
        return;
    }
    NSArray/*<NSString>*/ *o_in_alternateColors = objcStringArray(&in_alternateColors);
    std::optional<TestProtocolDatabaseExecuteNoOptionalParametersPrintColor> o_in_printColor = fromProtocolString<TestProtocolDatabaseExecuteNoOptionalParametersPrintColor>(in_printColor);
    if (!o_in_printColor) {
        backendDispatcher()->reportProtocolError(BackendDispatcher::InvalidParams, String::format("Parameter '%s' of method '%s' cannot be processed", "printColor", "Database.executeNoOptionalParameters"));
        return;
    }

    [m_delegate executeNoOptionalParametersWithErrorCallback:errorCallback successCallback:successCallback columnNames:o_in_columnNames notes:o_in_notes timestamp:o_in_timestamp values:o_in_values payload:o_in_payload databaseId:o_in_databaseId sqlError:o_in_sqlError screenColor:o_in_screenColor.value() alternateColors:o_in_alternateColors printColor:o_in_printColor.value()];
}


} // namespace Inspector

### End File: TestProtocolBackendDispatchers.mm

### Begin File: TestProtocolConfiguration.h
/*
 * Copyright (C) 2013 Google Inc. All rights reserved.
 * Copyright (C) 2013-2016 Apple Inc. All rights reserved.
 * Copyright (C) 2014 University of Washington. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

// DO NOT EDIT THIS FILE. It is automatically generated from commands-with-optional-call-return-parameters.json
// by the script: Source/JavaScriptCore/inspector/scripts/generate-inspector-protocol-bindings.py

#import <WebInspector/TestProtocol.h>

__attribute__((visibility ("default")))
@interface TestProtocolConfiguration : NSObject
@property (nonatomic, retain, setter=setDatabaseHandler:) id<TestProtocolDatabaseDomainHandler> databaseHandler;
@end


### End File: TestProtocolConfiguration.h

### Begin File: TestProtocolConfiguration.mm
/*
 * Copyright (C) 2013 Google Inc. All rights reserved.
 * Copyright (C) 2013-2016 Apple Inc. All rights reserved.
 * Copyright (C) 2014 University of Washington. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

// DO NOT EDIT THIS FILE. It is automatically generated from commands-with-optional-call-return-parameters.json
// by the script: Source/JavaScriptCore/inspector/scripts/generate-inspector-protocol-bindings.py

#import "TestProtocolConfiguration.h"

#import "TestProtocolInternal.h"
#import "TestProtocolBackendDispatchers.h"
#import <JavaScriptCore/AlternateDispatchableAgent.h>
#import <JavaScriptCore/AugmentableInspectorController.h>
#import <JavaScriptCore/InspectorAlternateBackendDispatchers.h>
#import <JavaScriptCore/InspectorBackendDispatchers.h>

using namespace Inspector;

@implementation TestProtocolConfiguration
{
    AugmentableInspectorController* _controller;
    id<TestProtocolDatabaseDomainHandler> _databaseHandler;
}

- (instancetype)initWithController:(AugmentableInspectorController*)controller
{
    self = [super init];
    if (!self)
        return nil;
    ASSERT(controller);
    _controller = controller;
    return self;
}

- (void)dealloc
{
    [_databaseHandler release];
    [super dealloc];
}

- (void)setDatabaseHandler:(id<TestProtocolDatabaseDomainHandler>)handler
{
    if (handler == _databaseHandler)
        return;

    [_databaseHandler release];
    _databaseHandler = [handler retain];

    auto alternateDispatcher = std::make_unique<ObjCInspectorDatabaseBackendDispatcher>(handler);
    auto alternateAgent = std::make_unique<AlternateDispatchableAgent<DatabaseBackendDispatcher, AlternateDatabaseBackendDispatcher>>(ASCIILiteral("Database"), *_controller, WTFMove(alternateDispatcher));
    _controller->appendExtraAgent(WTFMove(alternateAgent));
}

- (id<TestProtocolDatabaseDomainHandler>)databaseHandler
{
    return _databaseHandler;
}

@end


### End File: TestProtocolConfiguration.mm

### Begin File: TestProtocolEventDispatchers.mm
/*
 * Copyright (C) 2013 Google Inc. All rights reserved.
 * Copyright (C) 2013-2016 Apple Inc. All rights reserved.
 * Copyright (C) 2014 University of Washington. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

// DO NOT EDIT THIS FILE. It is automatically generated from commands-with-optional-call-return-parameters.json
// by the script: Source/JavaScriptCore/inspector/scripts/generate-inspector-protocol-bindings.py

#import "TestProtocolInternal.h"

#import "TestProtocolTypeConversions.h"
#import <JavaScriptCore/InspectorValues.h>

using namespace Inspector;


### End File: TestProtocolEventDispatchers.mm

### Begin File: TestProtocol.h
/*
 * Copyright (C) 2013 Google Inc. All rights reserved.
 * Copyright (C) 2013-2016 Apple Inc. All rights reserved.
 * Copyright (C) 2014 University of Washington. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

// DO NOT EDIT THIS FILE. It is automatically generated from commands-with-optional-call-return-parameters.json
// by the script: Source/JavaScriptCore/inspector/scripts/generate-inspector-protocol-bindings.py

#import <Foundation/Foundation.h>

#import <WebInspector/RWIProtocolJSONObject.h>


@class TestProtocolDatabaseError;

typedef NS_ENUM(NSInteger, TestProtocolPlatform) {
    TestProtocolPlatformAll,
    TestProtocolPlatformGeneric,
    TestProtocolPlatformIOS,
    TestProtocolPlatformMacOS,
};


typedef NS_ENUM(NSInteger, TestProtocolDatabasePrimaryColors) {
    TestProtocolDatabasePrimaryColorsRed,
    TestProtocolDatabasePrimaryColorsGreen,
    TestProtocolDatabasePrimaryColorsBlue,
};

typedef NS_ENUM(NSInteger, TestProtocolDatabaseExecuteAllOptionalParametersPrintColor) {
    TestProtocolDatabaseExecuteAllOptionalParametersPrintColorCyan,
    TestProtocolDatabaseExecuteAllOptionalParametersPrintColorMagenta,
    TestProtocolDatabaseExecuteAllOptionalParametersPrintColorYellow,
    TestProtocolDatabaseExecuteAllOptionalParametersPrintColorBlack,
};

typedef NS_ENUM(NSInteger, TestProtocolDatabaseExecuteAllOptionalParametersPrintColor) {
    TestProtocolDatabaseExecuteAllOptionalParametersPrintColorCyan,
    TestProtocolDatabaseExecuteAllOptionalParametersPrintColorMagenta,
    TestProtocolDatabaseExecuteAllOptionalParametersPrintColorYellow,
    TestProtocolDatabaseExecuteAllOptionalParametersPrintColorBlack,
};

typedef NS_ENUM(NSInteger, TestProtocolDatabaseExecuteNoOptionalParametersPrintColor) {
    TestProtocolDatabaseExecuteNoOptionalParametersPrintColorCyan,
    TestProtocolDatabaseExecuteNoOptionalParametersPrintColorMagenta,
    TestProtocolDatabaseExecuteNoOptionalParametersPrintColorYellow,
    TestProtocolDatabaseExecuteNoOptionalParametersPrintColorBlack,
};

typedef NS_ENUM(NSInteger, TestProtocolDatabaseExecuteNoOptionalParametersPrintColor) {
    TestProtocolDatabaseExecuteNoOptionalParametersPrintColorCyan,
    TestProtocolDatabaseExecuteNoOptionalParametersPrintColorMagenta,
    TestProtocolDatabaseExecuteNoOptionalParametersPrintColorYellow,
    TestProtocolDatabaseExecuteNoOptionalParametersPrintColorBlack,
};


__attribute__((visibility ("default")))
@interface TestProtocolDatabaseError : RWIProtocolJSONObject
- (instancetype)initWithPayload:(NSDictionary<NSString *, id> *)payload;
- (instancetype)initWithJSONObject:(RWIProtocolJSONObject *)jsonObject;
- (instancetype)initWithMessage:(NSString *)message code:(int)code;
/* required */ @property (nonatomic, copy) NSString *message;
/* required */ @property (nonatomic, assign) int code;
@end

@protocol TestProtocolDatabaseDomainHandler <NSObject>
@required
- (void)executeAllOptionalParametersWithErrorCallback:(void(^)(NSString *error))errorCallback successCallback:(void(^)(NSArray/*<NSString>*/ **columnNames, NSString **notes, double *timestamp, RWIProtocolJSONObject **values, RWIProtocolJSONObject **payload, int *databaseId, TestProtocolDatabaseError **sqlError, TestProtocolDatabasePrimaryColors *screenColor, NSArray/*<NSString>*/ **alternateColors, TestProtocolDatabaseExecuteAllOptionalParametersPrintColor *printColor))successCallback columnNames:(NSArray/*<NSString>*/ **)columnNames notes:(NSString **)notes timestamp:(double *)timestamp values:(RWIProtocolJSONObject **)values payload:(RWIProtocolJSONObject **)payload databaseId:(int *)databaseId sqlError:(TestProtocolDatabaseError **)sqlError screenColor:(TestProtocolDatabasePrimaryColors *)screenColor alternateColors:(NSArray/*<NSString>*/ **)alternateColors printColor:(TestProtocolDatabaseExecuteAllOptionalParametersPrintColor *)printColor;
- (void)executeNoOptionalParametersWithErrorCallback:(void(^)(NSString *error))errorCallback successCallback:(void(^)(NSArray/*<NSString>*/ *columnNames, NSString *notes, double timestamp, RWIProtocolJSONObject *values, RWIProtocolJSONObject *payload, int databaseId, TestProtocolDatabaseError *sqlError, TestProtocolDatabasePrimaryColors screenColor, NSArray/*<NSString>*/ *alternateColors, TestProtocolDatabaseExecuteNoOptionalParametersPrintColor printColor))successCallback columnNames:(NSArray/*<NSString>*/ *)columnNames notes:(NSString *)notes timestamp:(double)timestamp values:(RWIProtocolJSONObject *)values payload:(RWIProtocolJSONObject *)payload databaseId:(int)databaseId sqlError:(TestProtocolDatabaseError *)sqlError screenColor:(TestProtocolDatabasePrimaryColors)screenColor alternateColors:(NSArray/*<NSString>*/ *)alternateColors printColor:(TestProtocolDatabaseExecuteNoOptionalParametersPrintColor)printColor;
@end




### End File: TestProtocol.h

### Begin File: TestProtocolInternal.h
/*
 * Copyright (C) 2013 Google Inc. All rights reserved.
 * Copyright (C) 2013-2016 Apple Inc. All rights reserved.
 * Copyright (C) 2014 University of Washington. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

// DO NOT EDIT THIS FILE. It is automatically generated from commands-with-optional-call-return-parameters.json
// by the script: Source/JavaScriptCore/inspector/scripts/generate-inspector-protocol-bindings.py

#import "TestProtocol.h"
#import "TestProtocolJSONObjectPrivate.h"
#import <JavaScriptCore/AugmentableInspectorController.h>
#import <JavaScriptCore/InspectorValues.h>




### End File: TestProtocolInternal.h

### Begin File: TestProtocolTypeConversions.h
/*
 * Copyright (C) 2013 Google Inc. All rights reserved.
 * Copyright (C) 2013-2016 Apple Inc. All rights reserved.
 * Copyright (C) 2014 University of Washington. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

// DO NOT EDIT THIS FILE. It is automatically generated from commands-with-optional-call-return-parameters.json
// by the script: Source/JavaScriptCore/inspector/scripts/generate-inspector-protocol-bindings.py

#import "TestProtocol.h"
#import <WebInspector/RWIProtocolArrayConversions.h>

namespace Inspector {

template<typename ObjCEnumType>
std::optional<ObjCEnumType> fromProtocolString(const String& value);

inline String toProtocolString(TestProtocolPlatform value)
{
    switch(value) {
    case TestProtocolPlatformAll:
        return ASCIILiteral("all");
    case TestProtocolPlatformGeneric:
        return ASCIILiteral("generic");
    case TestProtocolPlatformIOS:
        return ASCIILiteral("ios");
    case TestProtocolPlatformMacOS:
        return ASCIILiteral("macos");
    }
}

template<>
inline std::optional<TestProtocolPlatform> fromProtocolString(const String& value)
{
    if (value == "all")
        return TestProtocolPlatformAll;
    if (value == "generic")
        return TestProtocolPlatformGeneric;
    if (value == "ios")
        return TestProtocolPlatformIOS;
    if (value == "macos")
        return TestProtocolPlatformMacOS;
    return std::nullopt;
}


inline String toProtocolString(TestProtocolDatabasePrimaryColors value)
{
    switch(value) {
    case TestProtocolDatabasePrimaryColorsRed:
        return ASCIILiteral("red");
    case TestProtocolDatabasePrimaryColorsGreen:
        return ASCIILiteral("green");
    case TestProtocolDatabasePrimaryColorsBlue:
        return ASCIILiteral("blue");
    }
}

template<>
inline std::optional<TestProtocolDatabasePrimaryColors> fromProtocolString(const String& value)
{
    if (value == "red")
        return TestProtocolDatabasePrimaryColorsRed;
    if (value == "green")
        return TestProtocolDatabasePrimaryColorsGreen;
    if (value == "blue")
        return TestProtocolDatabasePrimaryColorsBlue;
    return std::nullopt;
}

inline String toProtocolString(TestProtocolDatabaseExecuteAllOptionalParametersPrintColor value)
{
    switch(value) {
    case TestProtocolDatabaseExecuteAllOptionalParametersPrintColorCyan:
        return ASCIILiteral("cyan");
    case TestProtocolDatabaseExecuteAllOptionalParametersPrintColorMagenta:
        return ASCIILiteral("magenta");
    case TestProtocolDatabaseExecuteAllOptionalParametersPrintColorYellow:
        return ASCIILiteral("yellow");
    case TestProtocolDatabaseExecuteAllOptionalParametersPrintColorBlack:
        return ASCIILiteral("black");
    }
}

template<>
inline std::optional<TestProtocolDatabaseExecuteAllOptionalParametersPrintColor> fromProtocolString(const String& value)
{
    if (value == "cyan")
        return TestProtocolDatabaseExecuteAllOptionalParametersPrintColorCyan;
    if (value == "magenta")
        return TestProtocolDatabaseExecuteAllOptionalParametersPrintColorMagenta;
    if (value == "yellow")
        return TestProtocolDatabaseExecuteAllOptionalParametersPrintColorYellow;
    if (value == "black")
        return TestProtocolDatabaseExecuteAllOptionalParametersPrintColorBlack;
    return std::nullopt;
}

inline String toProtocolString(TestProtocolDatabaseExecuteAllOptionalParametersPrintColor value)
{
    switch(value) {
    case TestProtocolDatabaseExecuteAllOptionalParametersPrintColorCyan:
        return ASCIILiteral("cyan");
    case TestProtocolDatabaseExecuteAllOptionalParametersPrintColorMagenta:
        return ASCIILiteral("magenta");
    case TestProtocolDatabaseExecuteAllOptionalParametersPrintColorYellow:
        return ASCIILiteral("yellow");
    case TestProtocolDatabaseExecuteAllOptionalParametersPrintColorBlack:
        return ASCIILiteral("black");
    }
}

template<>
inline std::optional<TestProtocolDatabaseExecuteAllOptionalParametersPrintColor> fromProtocolString(const String& value)
{
    if (value == "cyan")
        return TestProtocolDatabaseExecuteAllOptionalParametersPrintColorCyan;
    if (value == "magenta")
        return TestProtocolDatabaseExecuteAllOptionalParametersPrintColorMagenta;
    if (value == "yellow")
        return TestProtocolDatabaseExecuteAllOptionalParametersPrintColorYellow;
    if (value == "black")
        return TestProtocolDatabaseExecuteAllOptionalParametersPrintColorBlack;
    return std::nullopt;
}

inline String toProtocolString(TestProtocolDatabaseExecuteNoOptionalParametersPrintColor value)
{
    switch(value) {
    case TestProtocolDatabaseExecuteNoOptionalParametersPrintColorCyan:
        return ASCIILiteral("cyan");
    case TestProtocolDatabaseExecuteNoOptionalParametersPrintColorMagenta:
        return ASCIILiteral("magenta");
    case TestProtocolDatabaseExecuteNoOptionalParametersPrintColorYellow:
        return ASCIILiteral("yellow");
    case TestProtocolDatabaseExecuteNoOptionalParametersPrintColorBlack:
        return ASCIILiteral("black");
    }
}

template<>
inline std::optional<TestProtocolDatabaseExecuteNoOptionalParametersPrintColor> fromProtocolString(const String& value)
{
    if (value == "cyan")
        return TestProtocolDatabaseExecuteNoOptionalParametersPrintColorCyan;
    if (value == "magenta")
        return TestProtocolDatabaseExecuteNoOptionalParametersPrintColorMagenta;
    if (value == "yellow")
        return TestProtocolDatabaseExecuteNoOptionalParametersPrintColorYellow;
    if (value == "black")
        return TestProtocolDatabaseExecuteNoOptionalParametersPrintColorBlack;
    return std::nullopt;
}

inline String toProtocolString(TestProtocolDatabaseExecuteNoOptionalParametersPrintColor value)
{
    switch(value) {
    case TestProtocolDatabaseExecuteNoOptionalParametersPrintColorCyan:
        return ASCIILiteral("cyan");
    case TestProtocolDatabaseExecuteNoOptionalParametersPrintColorMagenta:
        return ASCIILiteral("magenta");
    case TestProtocolDatabaseExecuteNoOptionalParametersPrintColorYellow:
        return ASCIILiteral("yellow");
    case TestProtocolDatabaseExecuteNoOptionalParametersPrintColorBlack:
        return ASCIILiteral("black");
    }
}

template<>
inline std::optional<TestProtocolDatabaseExecuteNoOptionalParametersPrintColor> fromProtocolString(const String& value)
{
    if (value == "cyan")
        return TestProtocolDatabaseExecuteNoOptionalParametersPrintColorCyan;
    if (value == "magenta")
        return TestProtocolDatabaseExecuteNoOptionalParametersPrintColorMagenta;
    if (value == "yellow")
        return TestProtocolDatabaseExecuteNoOptionalParametersPrintColorYellow;
    if (value == "black")
        return TestProtocolDatabaseExecuteNoOptionalParametersPrintColorBlack;
    return std::nullopt;
}

} // namespace Inspector

### End File: TestProtocolTypeConversions.h

### Begin File: TestProtocolTypeConversions.mm
/*
 * Copyright (C) 2013 Google Inc. All rights reserved.
 * Copyright (C) 2013-2016 Apple Inc. All rights reserved.
 * Copyright (C) 2014 University of Washington. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

// DO NOT EDIT THIS FILE. It is automatically generated from commands-with-optional-call-return-parameters.json
// by the script: Source/JavaScriptCore/inspector/scripts/generate-inspector-protocol-bindings.py

#import "TestProtocolTypeConversions.h"

#import "TestProtocol.h"
#import "TestProtocolTypeParser.h"
#import <WebInspector/RWIProtocolJSONObjectPrivate.h>

using namespace Inspector;

@interface TestProtocolTypeConversions (DatabaseDomain)

+ (void)_parseDatabaseId:(NSNumber **)outValue fromPayload:(id)payload;
+ (void)_parsePrimaryColors:(NSNumber **)outValue fromPayload:(id)payload;
+ (void)_parseColorList:(NSArray/*<NSString>*/ **)outValue fromPayload:(id)payload;
+ (void)_parseError:(TestProtocolDatabaseError **)outValue fromPayload:(id)payload;

@end

@implementation TestProtocolTypeConversions (DatabaseDomain)

+ (void)_parseDatabaseId:(NSNumber **)outValue fromPayload:(id)payload
{
    THROW_EXCEPTION_FOR_BAD_TYPE(payload, [NSNumber class]);
    *outValue = (NSNumber *)payload;
}

+ (void)_parsePrimaryColors:(NSNumber **)outValue fromPayload:(id)payload
{
    THROW_EXCEPTION_FOR_BAD_TYPE(payload, [NSString class]);
    std::optional<TestProtocolDatabasePrimaryColors> result = Inspector::fromProtocolString<TestProtocolDatabasePrimaryColors>(payload);
    THROW_EXCEPTION_FOR_BAD_ENUM_VALUE(result, @"PrimaryColors");
    *outValue = @(result.value());
}

+ (void)_parseColorList:(NSArray/*<NSString>*/ **)outValue fromPayload:(id)payload
{
    THROW_EXCEPTION_FOR_BAD_TYPE(payload, [NSArray/*<NSString>*/ class]);
    *outValue = (NSArray/*<NSString>*/ *)payload;
}

+ (void)_parseError:(TestProtocolDatabaseError **)outValue fromPayload:(id)payload
{
    THROW_EXCEPTION_FOR_BAD_TYPE(payload, [NSDictionary class]);
    *outValue = [[TestProtocolDatabaseError alloc] initWithPayload:payload];
}

@end


### End File: TestProtocolTypeConversions.mm

### Begin File: TestProtocolTypes.mm
/*
 * Copyright (C) 2013 Google Inc. All rights reserved.
 * Copyright (C) 2013-2016 Apple Inc. All rights reserved.
 * Copyright (C) 2014 University of Washington. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

// DO NOT EDIT THIS FILE. It is automatically generated from commands-with-optional-call-return-parameters.json
// by the script: Source/JavaScriptCore/inspector/scripts/generate-inspector-protocol-bindings.py

#import "TestProtocolInternal.h"

#import "TestProtocolTypeConversions.h"
#import <WebInspector/RWIProtocolJSONObjectPrivate.h>
#import <JavaScriptCore/InspectorValues.h>
#import <wtf/Assertions.h>

using namespace Inspector;


@implementation TestProtocolDatabaseError

- (instancetype)initWithPayload:(nonnull NSDictionary<NSString *, id> *)payload
{
    if (!(self = [super init]))
        return nil;

    THROW_EXCEPTION_FOR_REQUIRED_PROPERTY(payload[@"message"], @"message");
    self.message = payload[@"message"];

    THROW_EXCEPTION_FOR_REQUIRED_PROPERTY(payload[@"code"], @"code");
    self.code = [payload[@"code"] integerValue];

    return self;
}
- (instancetype)initWithJSONObject:(RWIProtocolJSONObject *)jsonObject
{
    if (!(self = [super initWithInspectorObject:[jsonObject toInspectorObject].get()]))
        return nil;

    return self;
}

- (instancetype)initWithMessage:(NSString *)message code:(int)code
{
    if (!(self = [super init]))
        return nil;

    THROW_EXCEPTION_FOR_REQUIRED_PROPERTY(message, @"message");

    self.message = message;
    self.code = code;

    return self;
}

- (void)setMessage:(NSString *)message
{
    [super setString:message forKey:@"message"];
}

- (NSString *)message
{
    return [super stringForKey:@"message"];
}

- (void)setCode:(int)code
{
    [super setInteger:code forKey:@"code"];
}

- (int)code
{
    return [super integerForKey:@"code"];
}

@end


### End File: TestProtocolTypes.mm
