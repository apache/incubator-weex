/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

import { isArray, createEvent, createBubblesEvent } from '../utils'
import config from '../config'

// The space used to store the tap event queue
const _tapQueue = []
/**
 * remove text nodes in the nodes array.
 * @param  {Array} nodes
 * @return {Array} nodes without text nodes.
 */
export function trimTextVNodes (vnodes) {
  if (isArray(vnodes)) {
    return vnodes.filter(vnode => !!vnode.tag)
  }
  return vnodes
}

/**
 * is a element in a '<a>' tag?
 * @param {HTMLElement} el
 */
function isInANode (el) {
  let parent = el.parentNode
  while (parent && parent !== document.body) {
    if (parent.tagName.toLowerCase() === 'a') {
      return true
    }
    parent = parent.parentNode
  }
}

/**
 * get listeners from on config and v-on binding.
 * v-on binding has a priority over on config.
 * @param {vnode} vnode
 * @param {String} evt: event name.
 */
function getListeners (vnode, evt) {
  const handlers = []
  while (vnode) {
    if (vnode.data && vnode.data.on) {
      const handler = vnode.data.on[evt]
      handler && handlers.push(handler)
    }
    if (vnode.componentOptions && vnode.componentOptions.listeners) {
      const handler = vnode.componentOptions.listeners[evt]
      handler && handlers.push(handler)
    }
    vnode = vnode.parent
  }
  return handlers
}

const supportedEvents = [
  'longpress', 'appear', 'disappear',
  'touchstart', 'touchmove', 'touchend',
  'panstart', 'panmove', 'panend', 'swipe', 'longpress'
]

/**
 * emit native events to enable v-on.
 * @param {VComponent} context: which one to emit a event on.
 * @param {array | object} extras: extra events. You can pass in multiple arguments here.
 */
export function createEventMap (context, ...extras) {
  const eventMap = {}
  const gestureEvents = config.gestureEvents
  /**
   * Bind some original type event to your specified type event handler.
   * e.g. bind 'tap' event to 'click' event listener: bindFunc('tap')('click').
   * Or bind certian event with your specified handler: bindFunc('click', someFunction)
   */
  const bindFunc = (originalType) => {
    return listenTo => {
      let handler
      const evtName = originalType || listenTo
      if (typeof listenTo === 'function') {
        handler = listenTo
      }
      else if (typeof listenTo === 'string') {
        handler = function (e) {
          /**
           * 1. use '_triggered' to control actural bubbling (allow original bubbling).
           * 2. use '_for' to distinguish from gesture events generated by other
           *    not-vue-render librarys.
           */
          if (e._triggered
            || gestureEvents.indexOf(originalType) > -1
            && e._for !== 'weex') {
            return
          }
          // but should trigger the closest parent which has bound the
          // event handler.
          let vm = context
          while (vm) {
            const ons = getListeners(vm.$vnode, listenTo)
            const len = ons.length
            if (len > 0) {
              let idx = 0
              while (idx < len) {
                let on = ons[idx]
                if (on && on.fn) {
                  on = on.fn
                }
                let evt = e
                if (originalType && evtName !== listenTo) {
                  if (listenTo === 'click') {
                    // dispatch real target click event befor calling listeners
                    evt = createBubblesEvent(e.target, 'click', { _triggered: { el: e.target }})
                    e.target.dispatchEvent(evt)
                  }
                  else {
                    evt = createEvent(e.target, listenTo)
                  }
                }
                on && on.call(vm, evt)
                idx++
              }
              // once a parent node (or self node) has triggered the handler, then
              // it stops bubbling immediately, and a '_triggered' object is set.
              e._triggered = {
                el: vm.$el
              }
              // when originalType is tap, push a tapEvent to _tapQueue
              // el is uesed to store a real target which dispach this event
              if (originalType === 'tap') {
                const tapEvent = {
                  el: e.target,
                  event: e
                }
                _tapQueue.push(tapEvent)
              }
              return
            }
            vm = vm.$parent
          }
        }
      }
      if (!eventMap[evtName]) {
        eventMap[evtName] = []
      }
      eventMap[evtName].push(handler)
    }
  }

  /**
   * 1. Dispatch default supported events directly to user's event listeners. These
   * listeners will be triggered before extras event handlers.
   */
  supportedEvents.forEach(bindFunc())

  /**
   * 2. component's extra event bindings. This is mostly for the needs of component's
   * own special behaviours. These handlers will be processed after the user's
   * corresponding event handlers.
   */
  if (extras) {
    const len = extras.length
    for (let i = 0; i < len; i++) {
      const extra = extras[i]
      if (isArray(extra)) {
        extra.forEach(bindFunc())
      }
      else if (typeof extra === 'object') {
        for (const key in extra) {
          bindFunc(key)(extra[key])
        }
      }
    }
  }

  /**
   * 3. special binding for click event, which should be a fastclick event without
   * 300ms latency.
   */
  bindFunc('tap')('click')
  /**
   * Special treatment for click event:
   * we already use tap to trigger click event, so the click event should:
   * 1. trigger none of any vm's click listeners.
   * 2. prevent default behaviour for a `<a>` element.
   * 3. stop propagation if triggered already.
   * 4. set a _triggered flag to the event object if triggered already.
   * This means the click event should always be swallowed in silence.
   */
  bindFunc('click')(function (e) {
    let vm = context
    if (e._triggered) {
      return
    }
    if (_tapQueue.length > 0) {
      const _tapEvent = _tapQueue.shift()
      if (e.target !== _tapEvent.el) {
        e.preventDefault()
      }
      // prevent click events from bubbling,because event bubbling has been handled in the tap event
      e.stopPropagation()
    }
    // if an element(not <a>) handler click event in <a> element,call stopPropagation and preventDefault on event
    while (vm) {
      const ons = getListeners(vm.$vnode, 'click')
      const len = ons.length
      if (len > 0 && vm.$el) {
        e._triggered = { el: vm.$el }
        return isInANode(vm.$el) && e.preventDefault()
      }
      vm = vm.$parent
    }
  })
  return eventMap
}
