# JS Framework APIs
<span class="weex-version">0.4</span>
<a href="https://github.com/weexteam/article/wiki/%E6%AC%A2%E8%BF%8E%E5%8F%82%E4%B8%8EWeex%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91"  class="weex-translate incomplete">cn</a>

## Intro about JS Runtime

These APIs are designed for JS Framework and Native Engine working together.

Considering the limitation of mobile phone resource, *Weex runs only one JS runtime* to handle all Weex instances. So it need a multi-instance management layer in JavaScript. These JS Framework APIs are just designed to do the management job.

* First, each Weex instance have a lifecycle, from `createInstance` to `destroyInstance`. During this period, we can import some extra data by `refreshInstance`.
* To communicate with Native Engine, we have a couple of APIs: `callNative` and `callJS`. They are used to call each other by some commands and messages.
* And when JS runtime start at the beginning of the app launching, we need something initialized and configured. So we supply some APIs like `registerComponents`, `registerModules`.
* The last API is just for debugging, we supply an API named `getRoot` to return the whole virtual-DOM data for developers.

## Called by native and supplied from JS Framework

### `createInstance(instanceId, code, options, data)`

Create a Weex instance from Native Engine

* `instanceId`: The unique id for a Weex instance, generated by Native Engine.
* `code`: The JS bundle code send from Native Engine. It will be executed by `new Function(code)` in JS Framework. The code format depends on [JS Bundle Foramt](js-bundle-format.md)
* `options`: *Optional*. An options object. *Currently it supports `debug` flag which enable printing log and `bundleUrl` flag which the url of bundle.*
* `data`: *Optional*. It's an chance to supply external data instead of the original data in JS bundle.

Example:

```
createInstance('x', 'define(...); define(...); define(...); bootstrap(...)')
createInstance('x', '...', { bundleUrl, debug, ... }, { a: 1, b: 2 }})
```

### `destroyInstance(instanceId)`

Destroy an existed Weex instance by id from Native Engine

### `refreshInstance(instanceId, data)`

Refresh data to an existed Weex instance with certain external data from Native Engine

Example:

```
refreshInstance('x', {a: 100, b: 200})
```

### `registerComponents(components)`

Register all native components

* `components`: A map of which keys are component types and values are force options part of each type of component. *Currently it supports `append` attribute which forces the appending mechanism (`tree` or `node`) when first time rendering.*

Example:

```
registerComponents({
  container: {},
  text: {},
  image: {},
  slider: {append: 'tree'},
  list: {},
  cell: {append: 'tree'},
  ...
})
```

### `registerModules(modules)`

Register the name, methods and args format of each module

* `modules`: A map that collects all native module definitions. Each module definition is an array which has several API definitions. Each API definition has a `name` string and an `args` array which contains a list of each parameter's type.

**NOTE: the `node` type data will actually return its `ref` property. And the `function` type data will actually return a unique function id referring to it.**

Example:

```
registerModules({
  event: [
    {name: 'openURL', args: ['string']}
  ],
  ...
})
```

### `callJS(instanceId, tasks)`

Fire events or callbacks to an existed Weex instance from Native Engine

* `tasks[]`: A task list. Each task has a `method="fireEvent|callback"` property and a list of `args`.
    - In `fireEvent` method, the `args` is `ref` of the target, event `type`, event `data` and `domChanges` description in order. **Note: if some event make virtual-DOM data changed (e.g. value changed in `<input>` or current index changed in `<slider>`), the changing of the target element will be passed as `domChanges`.**
    - In `callback` method, the `args` is `funcId` of a handler, `data` and `ifKeepAlive` which describes whether this callback handler should be keeping called. (Each callback handler is matched with a `funcId` when the original call happens.)

Example:

```
callJS('x', [{method: 'fireEvent', args: ['x', '13', 'click', {a: 100, b: 200}]}])
callJS('x', [{method: 'callback', args: ['x', '7', {a: 100, b: 200}, true]}])
```

### `getRoot(instanceId)`

Return a JSON object which describes the whole virtual DOM body of an existed Weex instance, which designed for debugging

Example:

```
getRoot('x')
// {ref: '_root', type: 'container', attr: {...}, style: {...}, children: [...]}
```

## Called from JavaScript and implemented with native code

### `callNative(instanceId, tasks)`

Make native calls from JS Framework

* `tasks[]`: A task list. Each task has a `module` name, a `method` name, and a `args[]` list.

Example:

```
callNative('x', [
  {module: 'dom', method: 'addElement', args: ['_root', {ref: '1', type: 'container'}, -1]},
  {module: 'dom', method: 'addElement', args: ['1', {ref: '2', type: 'text', ...}, -1]},
  {module: 'dom', method: 'addElement', args: ['1', {ref: '3', type: 'image', ...}, -1]},
  ...
])
```
